// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package app

import (
	"context"
	"fmt"
	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/go-kratos/kratos/contrib/registry/consul/v2"
	"github.com/go-kratos/kratos/v2/registry"
	grpc2 "github.com/go-kratos/kratos/v2/transport/grpc"
	"github.com/go-redis/redis/v8"
	"github.com/hashicorp/consul/api"
	"golang.org/x/exp/slog"
	"google.golang.org/grpc"
	"gorm.io/gorm"
	"hospital-system/proto_gen/authorization/v1"
	"hospital-system/server/api/v1"
	"hospital-system/server/api/v1/admin"
	session2 "hospital-system/server/api/v1/session"
	"hospital-system/server/app/repositories/admission"
	"hospital-system/server/app/repositories/patient"
	"hospital-system/server/app/repositories/user"
	"hospital-system/server/app/services/department"
	patient2 "hospital-system/server/app/services/patient"
	"hospital-system/server/app/services/session"
	user2 "hospital-system/server/app/services/user"
	"hospital-system/server/config"
	"hospital-system/server/db"
	"time"
)

// Injectors from wire.go:

func Build(cfg config.Config) (*gin.Engine, func(), error) {
	gormDB, err := db.OpenConnection(cfg)
	if err != nil {
		return nil, nil, err
	}
	client, cleanup := provideRedisClient(cfg)
	discovery := provideRegistry(cfg)
	authorizationServiceClient, cleanup2 := provideUserClient(cfg, discovery)
	api := buildAPI(gormDB, cfg, client, authorizationServiceClient)
	engine := initializeApp(api, cfg)
	return engine, func() {
		cleanup2()
		cleanup()
	}, nil
}

func buildAPI(db2 *gorm.DB, cfg config.Config, redisClient *redis.Client, userClient authorization.AuthorizationServiceClient) *v1.API {
	repositoryImpl := user.NewRepository(db2)
	serviceImpl := user2.NewService(userClient, repositoryImpl)
	patientRepositoryImpl := patient.NewRepository(db2)
	admissionRepositoryImpl := admission.NewRepository(db2)
	patientServiceImpl := patient2.NewService(userClient, patientRepositoryImpl, admissionRepositoryImpl)
	departmentServiceImpl := department.NewService(userClient, repositoryImpl)
	handlerImpl := admin.NewHandler(serviceImpl, patientServiceImpl, departmentServiceImpl)
	sessionServiceImpl := session.NewService(redisClient, cfg)
	sessionHandlerImpl := session2.NewHandler(serviceImpl, sessionServiceImpl)
	api := v1.NewAPI(handlerImpl, sessionHandlerImpl, sessionServiceImpl)
	return api
}

// wire.go:

func initializeApp(api *v1.API, cfg config.Config) *gin.Engine {
	router := gin.Default()
	config2 := cors.DefaultConfig()
	config2.
		AllowOrigins = []string{cfg.Web.ClientAppUrl}
	config2.
		AllowCredentials = true
	config2.
		AllowHeaders = append(config2.AllowHeaders, "Authorization")
	router.Use(cors.New(config2))

	api.RegisterRoutes(router)

	return router
}

func provideRedisClient(cfg config.Config) (*redis.Client, func()) {
	client := redis.NewClient(&redis.Options{
		Addr:     fmt.Sprintf("%s:%s", cfg.Redis.Host, cfg.Redis.Port),
		Password: cfg.Redis.Password,
		DB:       cfg.Redis.DatabaseIndex,
	})

	return client, func() {
		if err := client.Close(); err != nil {
			slog.Error(fmt.Sprintf("Failed to close Redis client. Error:\n%v", err))
			panic(err)
		}
	}
}

func provideUserClient(config2 config.Config, discovery registry.Discovery) (authorization.AuthorizationServiceClient, func()) {

	conn := provideConnection("authorization", discovery)
	return authorization.NewAuthorizationServiceClient(conn), func() {
		if err := conn.Close(); err != nil {
			panic(fmt.Sprintf("Failed to close connection. Error:\n%v", err))
		}
	}
}

func provideConnection(serviceName string, discovery registry.Discovery) *grpc.ClientConn {
	conn, err := grpc2.DialInsecure(context.Background(), grpc2.WithEndpoint(fmt.Sprintf("discovery:///%s", serviceName)), grpc2.WithDiscovery(discovery), grpc2.WithTimeout(time.Second*0))
	if err != nil {
		slog.Error(fmt.Sprintf("Failed to dial %s service. Error:\n%v", serviceName, err))
		return nil
	}

	return conn
}

func provideRegistry(cfg config.Config) registry.Discovery {
	consulConfig := api.DefaultConfig()
	consulConfig.Address = fmt.Sprintf("%s:%v", cfg.Registry.RegistrarHost, cfg.Registry.RegistrarPort)
	client, err := api.NewClient(consulConfig)
	if err != nil {
		panic(fmt.Sprintf("Failed to init Consul client. Error:\n%v", err))
	}

	return consul.New(client)
}
